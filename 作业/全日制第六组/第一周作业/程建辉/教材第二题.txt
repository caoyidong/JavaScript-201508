首先进行预解释，var number; var obj; var fn1;
第二步，代码从上到下执行，变量赋值。
number=2; obj=! {number:4,fn1:(function(){})()} 这时候obj还没有地址，变量赋值分为二步，预解释完了之后，首先为obj开辟一个堆内存，等堆内存的代码执行完了之后，obj才能得到内存地址，所以，fn1属性值 这个自执行的函数的的形参不可能为obj的，因为当为obj传形参的时候，obj还没有地址。

在其定义的堆内存中给fn1写值的时候其下边的自执行函
数已经执行了，在执行的过程中调用了全局下的number变量一次，并将其更改为4，所以这里输出4
fn1();//fn1所代表的地址是对象obj中fn1的自执行函数返回的结果，所以执行fn1，就是

返回的函数的执行，因为这里的fn1()前边没有"."，所以这里函数体中的this指的是全局下的this，所有把全局下的number变为8；下边用到了number这个变量，但是当前作用域中没有，需要向上级作用域查找，上级作用域中的number此时的结果为3，所以这里输出9
obj.fn1();//fn1所代表的地址是对象obj中fn1的自执行函数返回的结果，所以执行fn1
，就是返回的函数的执行，fn1()前边有"."，所以"."之前的就是此时函数体中this，所以把
obj下的number变为8，下边还是用到number这个变量，还是要往上级找，此时上级的number已经变为了9，所以这里输出27
alert(window.number);//上边一共调用全局下number两次，执行后的结果为8
alert(obj.number);//obj的number被调用一次，结果为8
 主要是分清楚是谁执行函数，里面的this是谁的，假如函数的引用地址被这个函数以外的变量占用的话，这个函数所在的作用域是不销毁的，