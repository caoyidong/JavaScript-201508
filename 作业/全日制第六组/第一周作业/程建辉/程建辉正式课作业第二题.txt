二(1) 首先进行预解释，var a; function(){console.log(a);  var a=13,}function 是引用数据类型，在预解释的时候就新开辟了空间，并定义了，不过，函数体是以字符串的形式存在堆内存中，


第二步代码从上到下执行，执行到console.log（a），这时候，a只是预解释了，并没有赋值，没有赋值的a输出为undefined。然后代码从上到下执行，执行到a=12；并给a赋值为12.当执行到function（）函数，第一次预解释的时候，已经定义了，所以，这次跳过，js不进行重复的预解释和定义，也就是js中没有重载机制，

下一步执行fn（），新开辟一个私有作用域，按照（形参赋值，预解释，代码执行这三步完成），具体到这就是 预解释 var a  第二步，代码执行，输出a为undefined，然后执行全局的console.log（a）。这时候全局的a还是12，全局和私有作用域的a互补影响。


（2） 首先进行预解释，var a; function(){console.log(a);  var a=13,}function 是引用数据类型，在预解释的时候就新开辟了空间，并定义了，不过，函数体是以字符串的形式存在堆内存中，

第二步代码从上到下执行，执行到console.log（a），这时候，a只是预解释了，并没有赋值，没有赋值的a输出为undefined。然后代码从上到下执行，执行到a=12；并给a赋值为12.当执行到function（）函数，第一次预解释的时候，已经定义了，所以，这次跳过，

下一步执行fn（），新开辟一个私有作用域，首先进行预解释，私有作用域里并没有带var关键字的，也就是说，这里用到的变量都是全局变量，所以console（a）输出的为全局的12，下一步执行到a=13，这里的a也是全局的，所以，全局的console（a）为13；

（3）首先进行预解释，这里并没有带var和function关键字的，也就没有进行预解释，代码从上到下执行，当console.log(a)，由于a并没有预解释过，所以输出为a is not defined.在没有进行变量声明的情况下，不能进行获取，可以进行添加，比如，给a添加一个a=12.相当于window.a=12；

（4） 首先进行预解释，var foo; function(){if(!foo){var foo=10;}console.log(foo);}function 是引用数据类型，在预解释的时候就新开辟了空间，并定义了，不过，函数体是以字符串的形式存在堆内存中，

第二步代码从上到下执行，执行到var foo的时候，并未foo赋值为1；当执行到function bar（）函数，第一次预解释的时候，已经定义了，所以，这次跳过，js不进行重复的预解释和定义，
当执行到bar（），开辟一个私有作用域进行还是进行预解释，代码从上到下执行，变量赋值。声明一个变量 var foo 代码从上到下执行，执行到if（！foo）这是foo的值为undefined，！foo的值为true，所以，这个if判断可以执行，foo=10.console.log(foo)为10；

（5） 首先进行预解释，var n; function(){}，函数体以字符串的形式存在，var c
第二步代码从上到下执行，n=0;遇到function 跳过去执行下面的代码。c=a(),首先执行a（），然后把返回值赋值给c。运行a（）；
开辟一个私有的作用域A，预解释，var n，预解释并定义function b（）{}，在A里面：n=0；跳过function b（），执行b（）。开辟一个私有作用域 B，执行n++；私有作用域里，并没有声明变量n，往上级作用域找n，找到A里面的n=10；然后n++；alert n=11；

然后return b，等于把b空间的内存地址返回，并由全局作用域的变量c接收，这时候这个A作用域是不销毁的，
c（），就等于运行function b（）{}，n++，等于A作用域的n++。这时，n=12.
第三步，执行全局的alert（n）；还是0；私有作用域的变量不影响全局的。

（6），首先，弄清楚，var a=10,b=11,c=12;相当于只对a进行了声明，function test（a）{}里的也同样，相当于只对b进行了声明。

进行预解释，var a; function(){}，函数体以字符串的形式存在，
然后代码从上到下执行，a=10,b=11,c=12;遇到function test（a）{}。跳过执行test（10）；开辟一个私有作用域Test，进行形参赋值，虽然这里没有变量接收变量a的值10，传值的作用起到保护私有变量的作用，这里的a为私有变量，私有作用域里面的预解释，var b，然后代码执行，a=1,var b=2, c=3（私有作用域没有声明变量c）所以这里的c为全局的 全局的c=3;
全局作用域的代码执行，alert（a为全局的a=10）alert（b为全局的b=11），alert（c=3）


7，预解释 var a  这时a就为window的属性，所以，！（"a"in window）=false;所以判断语句不执行，所以alert（a）为undefined;



8 首先进行预解释，var a; function b(x,y,a){} 是引用数据类型，在预解释的时候就新开辟了空间，并定义了，不过，函数体是以字符串的形式存在堆内存中，

第二步，代码执行，变量赋值，a=4；a=b（1,2,3）相当于执行b（），并把返回值赋值给a，首先为函数b（）传参数，x=1,y=2,a=3.都是私有变量，alert（a=3）。arguments[2]相当于把第三个参数a赋值10，所以alert（a=10）。私有作用域下并没有返回值，所以，全局下的a为undefined 所以alert（a=undefined）

9预解释 var foo 自执行函数在全局作用域的不进行解释，代码从上到下执行，变量赋值foo=‘hello’；代码从上到下执行 运行自执行函数，开辟一个私有作用域，传参数： foo的参数为全局的“hello”，让私有作用域的foo=“hello”。私有作用域的预解释，var foo ，代码从上到下执行，私有作用域的console.log（foo=“hello”），var foo=foo||'world';进行或运算，foo=‘hello’，私有作用域的console.log（foo=‘hello’），全局的console.log（foo=‘hello’）

10 先进行预解释var a, var f,var m,var n,var x; function b(x,y,a){} 是引用数据类型，在预解释的时候就新开辟了空间，并定义了，不过，函数体是以字符串的形式存在堆内存中，

第二步代码从上到下执行，变量赋值a=9；跳过function fn函数，f=fn(),执行fn（）这个函数，开辟一个私有作用域A，这里没有私有作用域的预解释， 并把返回值匿名函数的引用地址给***fff000给f，引用地址被其他变量引用，所以A这个私有作用域不能销毁，A作用域下的变量也不能销毁。return 后面的函数不进行预解释。
代码继续执行m=f(5),开辟一个私有作用域，首先传参数，b=5；这个私有作用域中没有a，往上级找到a=0；这里的a也是全局变量a。返回b+a++的值为5；a++的值为1，并保留了下来。


变量赋值n=fn()(5)；首先开辟一个私有的空间fn，没有预解释，返回匿名函数的索引，***fff000,然后***fff000（5）执行，返回值为5；

变量赋值x=f(5)匿名函数传值，这时候的a，是上级作用域的a，也是全局作用域的a，返回值为5+1=6；这时候、的a累加为2了，
所以输出全局的a为2











































